/* tslint:disable */
/* eslint-disable */
/**
 * DigiWF API
 * DigiWF - Plattform zur Digitalisierung von Workflows bei der LHM
 *
 * The version of the OpenAPI document: 0.1.0
 * Contact: itm.digiwf@muenchen.de
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AlwMetaDataTO
 */
export interface AlwMetaDataTO {
    /**
     * 
     * @type {string}
     * @memberof AlwMetaDataTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AlwMetaDataTO
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlwMetaDataTO
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlwMetaDataTO
     */
    'extension'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlwMetaDataTO
     */
    'contentSize'?: string;
}
/**
 * 
 * @export
 * @interface ButtonTO
 */
export interface ButtonTO {
    /**
     * 
     * @type {boolean}
     * @memberof ButtonTO
     */
    'showButton'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ButtonTO
     */
    'buttonText'?: string;
}
/**
 * 
 * @export
 * @interface ButtonsTO
 */
export interface ButtonsTO {
    /**
     * 
     * @type {ButtonTO}
     * @memberof ButtonsTO
     */
    'complete'?: ButtonTO;
    /**
     * 
     * @type {ButtonTO}
     * @memberof ButtonsTO
     */
    'cancel'?: ButtonTO;
    /**
     * 
     * @type {ButtonTO}
     * @memberof ButtonsTO
     */
    'statusPdf'?: ButtonTO;
}
/**
 * 
 * @export
 * @interface CompleteTO
 */
export interface CompleteTO {
    /**
     * 
     * @type {string}
     * @memberof CompleteTO
     */
    'taskId': string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof CompleteTO
     */
    'variables': { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface ConfigEntryTO
 */
export interface ConfigEntryTO {
    /**
     * 
     * @type {string}
     * @memberof ConfigEntryTO
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof ConfigEntryTO
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface DeploymentDto
 */
export interface DeploymentDto {
    /**
     * 
     * @type {string}
     * @memberof DeploymentDto
     */
    'deploymentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentDto
     */
    'versionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentDto
     */
    'target'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentDto
     */
    'file'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentDto
     */
    'artifactType'?: string;
}
/**
 * 
 * @export
 * @interface DeploymentStatusDto
 */
export interface DeploymentStatusDto {
    /**
     * 
     * @type {boolean}
     * @memberof DeploymentStatusDto
     */
    'success'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DeploymentStatusDto
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface FilterTO
 */
export interface FilterTO {
    /**
     * 
     * @type {string}
     * @memberof FilterTO
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof FilterTO
     */
    'filterString'?: string;
    /**
     * 
     * @type {string}
     * @memberof FilterTO
     */
    'pageId'?: string;
}
/**
 * 
 * @export
 * @interface FollowUpTO
 */
export interface FollowUpTO {
    /**
     * 
     * @type {string}
     * @memberof FollowUpTO
     */
    'taskId': string;
    /**
     * 
     * @type {string}
     * @memberof FollowUpTO
     */
    'followUpDate'?: string;
}
/**
 * 
 * @export
 * @interface FormFieldTO
 */
export interface FormFieldTO {
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    'defaultValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    'defaultValueField'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    'label'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    'prependIcon'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    'tooltip'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    'ext'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FormFieldTO
     */
    'multiple'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    'ldapOus'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    'imageHeight'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    'imageWidth'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FormFieldTO
     */
    'readonly'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof FormFieldTO
     */
    'rows'?: number;
    /**
     * 
     * @type {number}
     * @memberof FormFieldTO
     */
    'col'?: number;
    /**
     * 
     * @type {Array<ItemTO>}
     * @memberof FormFieldTO
     */
    'items'?: Array<ItemTO>;
    /**
     * 
     * @type {Array<RuleTO>}
     * @memberof FormFieldTO
     */
    'rules'?: Array<RuleTO>;
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    'itemText'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    'itemValue'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FormFieldTO
     */
    'returnObject'?: boolean;
}
/**
 * 
 * @export
 * @interface FormTO
 */
export interface FormTO {
    /**
     * 
     * @type {string}
     * @memberof FormTO
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof FormTO
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormTO
     */
    'authorizedGroups'?: string;
    /**
     * 
     * @type {ButtonsTO}
     * @memberof FormTO
     */
    'buttons'?: ButtonsTO;
    /**
     * 
     * @type {Array<GroupTO>}
     * @memberof FormTO
     */
    'groups'?: Array<GroupTO>;
}
/**
 * 
 * @export
 * @interface GetAlwMetadataTO
 */
export interface GetAlwMetadataTO {
    /**
     * 
     * @type {string}
     * @memberof GetAlwMetadataTO
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface GetMetadataTO
 */
export interface GetMetadataTO {
    /**
     * 
     * @type {string}
     * @memberof GetMetadataTO
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface GroupTO
 */
export interface GroupTO {
    /**
     * 
     * @type {string}
     * @memberof GroupTO
     */
    'label'?: string;
    /**
     * 
     * @type {Array<FormFieldTO>}
     * @memberof GroupTO
     */
    'schema'?: Array<FormFieldTO>;
}
/**
 * 
 * @export
 * @interface HistoryTask
 */
export interface HistoryTask {
    /**
     * 
     * @type {string}
     * @memberof HistoryTask
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof HistoryTask
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof HistoryTask
     */
    'endTime'?: string;
}
/**
 * 
 * @export
 * @interface HumanTaskDetailTO
 */
export interface HumanTaskDetailTO {
    /**
     * 
     * @type {string}
     * @memberof HumanTaskDetailTO
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskDetailTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskDetailTO
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskDetailTO
     */
    'processName': string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskDetailTO
     */
    'processInstanceId': string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskDetailTO
     */
    'assignee'?: string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskDetailTO
     */
    'assigneeFormatted'?: string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskDetailTO
     */
    'followUpDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskDetailTO
     */
    'creationTime': string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof HumanTaskDetailTO
     */
    'variables'?: { [key: string]: object; };
    /**
     * 
     * @type {FormTO}
     * @memberof HumanTaskDetailTO
     */
    'form'?: FormTO;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof HumanTaskDetailTO
     */
    'jsonSchema'?: { [key: string]: object; };
    /**
     * 
     * @type {boolean}
     * @memberof HumanTaskDetailTO
     */
    'statusDocument'?: boolean;
}
/**
 * 
 * @export
 * @interface HumanTaskTO
 */
export interface HumanTaskTO {
    /**
     * 
     * @type {string}
     * @memberof HumanTaskTO
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskTO
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskTO
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskTO
     */
    'processName'?: string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskTO
     */
    'assignee'?: string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskTO
     */
    'assigneeFormatted'?: string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskTO
     */
    'followUpDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskTO
     */
    'creationTime'?: string;
}
/**
 * 
 * @export
 * @interface InfoTO
 */
export interface InfoTO {
    /**
     * 
     * @type {string}
     * @memberof InfoTO
     */
    'maintenanceInfo1'?: string;
    /**
     * 
     * @type {string}
     * @memberof InfoTO
     */
    'maintenanceInfo2'?: string;
    /**
     * 
     * @type {string}
     * @memberof InfoTO
     */
    'environment'?: string;
}
/**
 * 
 * @export
 * @interface ItemTO
 */
export interface ItemTO {
    /**
     * 
     * @type {string}
     * @memberof ItemTO
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemTO
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface JsonSchemaTO
 */
export interface JsonSchemaTO {
    /**
     * 
     * @type {string}
     * @memberof JsonSchemaTO
     */
    'key': string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof JsonSchemaTO
     */
    'schema': { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface MetadataTO
 */
export interface MetadataTO {
    /**
     * 
     * @type {string}
     * @memberof MetadataTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MetadataTO
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetadataTO
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface PageHumanTaskTO
 */
export interface PageHumanTaskTO {
    /**
     * 
     * @type {number}
     * @memberof PageHumanTaskTO
     */
    'totalPages'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageHumanTaskTO
     */
    'totalElements'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageHumanTaskTO
     */
    'numberOfElements'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PageHumanTaskTO
     */
    'first'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageHumanTaskTO
     */
    'last'?: boolean;
    /**
     * 
     * @type {PageableObject}
     * @memberof PageHumanTaskTO
     */
    'pageable'?: PageableObject;
    /**
     * 
     * @type {number}
     * @memberof PageHumanTaskTO
     */
    'size'?: number;
    /**
     * 
     * @type {Array<HumanTaskTO>}
     * @memberof PageHumanTaskTO
     */
    'content'?: Array<HumanTaskTO>;
    /**
     * 
     * @type {number}
     * @memberof PageHumanTaskTO
     */
    'number'?: number;
    /**
     * 
     * @type {Sort}
     * @memberof PageHumanTaskTO
     */
    'sort'?: Sort;
    /**
     * 
     * @type {boolean}
     * @memberof PageHumanTaskTO
     */
    'empty'?: boolean;
}
/**
 * 
 * @export
 * @interface PageableObject
 */
export interface PageableObject {
    /**
     * 
     * @type {number}
     * @memberof PageableObject
     */
    'pageNumber'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageableObject
     */
    'pageSize'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PageableObject
     */
    'paged'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageableObject
     */
    'unpaged'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageableObject
     */
    'offset'?: number;
    /**
     * 
     * @type {Sort}
     * @memberof PageableObject
     */
    'sort'?: Sort;
}
/**
 * 
 * @export
 * @interface ProcessConfigTO
 */
export interface ProcessConfigTO {
    /**
     * 
     * @type {string}
     * @memberof ProcessConfigTO
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof ProcessConfigTO
     */
    'statusDokument'?: string;
    /**
     * 
     * @type {Array<StatusConfigTO>}
     * @memberof ProcessConfigTO
     */
    'statusConfig'?: Array<StatusConfigTO>;
    /**
     * 
     * @type {Array<ConfigEntryTO>}
     * @memberof ProcessConfigTO
     */
    'configs'?: Array<ConfigEntryTO>;
}
/**
 * 
 * @export
 * @interface RuleTO
 */
export interface RuleTO {
    /**
     * 
     * @type {string}
     * @memberof RuleTO
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof RuleTO
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof RuleTO
     */
    'target'?: string;
}
/**
 * 
 * @export
 * @interface SaveFilterTO
 */
export interface SaveFilterTO {
    /**
     * 
     * @type {string}
     * @memberof SaveFilterTO
     */
    'filterString': string;
    /**
     * 
     * @type {string}
     * @memberof SaveFilterTO
     */
    'pageId': string;
}
/**
 * 
 * @export
 * @interface SaveTO
 */
export interface SaveTO {
    /**
     * 
     * @type {string}
     * @memberof SaveTO
     */
    'taskId': string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof SaveTO
     */
    'variables'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface SearchUserTO
 */
export interface SearchUserTO {
    /**
     * 
     * @type {string}
     * @memberof SearchUserTO
     */
    'searchString'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchUserTO
     */
    'ous'?: string;
}
/**
 * 
 * @export
 * @interface SendMessageTO
 */
export interface SendMessageTO {
    /**
     * 
     * @type {string}
     * @memberof SendMessageTO
     */
    'instanceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SendMessageTO
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ServiceDefinitionDetailTO
 */
export interface ServiceDefinitionDetailTO {
    /**
     * 
     * @type {FormTO}
     * @memberof ServiceDefinitionDetailTO
     */
    'startForm'?: FormTO;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ServiceDefinitionDetailTO
     */
    'jsonSchema'?: { [key: string]: object; };
    /**
     * 
     * @type {string}
     * @memberof ServiceDefinitionDetailTO
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceDefinitionDetailTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceDefinitionDetailTO
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceDefinitionDetailTO
     */
    'versionTag'?: string;
}
/**
 * 
 * @export
 * @interface ServiceDefinitionTO
 */
export interface ServiceDefinitionTO {
    /**
     * 
     * @type {string}
     * @memberof ServiceDefinitionTO
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceDefinitionTO
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceDefinitionTO
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceDefinitionTO
     */
    'versionTag'?: string;
}
/**
 * 
 * @export
 * @interface ServiceInstanceDetailTO
 */
export interface ServiceInstanceDetailTO {
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceDetailTO
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceDetailTO
     */
    'definitionName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceDetailTO
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceDetailTO
     */
    'endTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceDetailTO
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceDetailTO
     */
    'statusKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceDetailTO
     */
    'description'?: string;
    /**
     * 
     * @type {ProcessConfigTO}
     * @memberof ServiceInstanceDetailTO
     */
    'processConfig'?: ProcessConfigTO;
    /**
     * 
     * @type {Array<HistoryTask>}
     * @memberof ServiceInstanceDetailTO
     */
    'historyTasks'?: Array<HistoryTask>;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ServiceInstanceDetailTO
     */
    'data'?: { [key: string]: object; };
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ServiceInstanceDetailTO
     */
    'jsonSchema'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface ServiceInstanceTO
 */
export interface ServiceInstanceTO {
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceTO
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceTO
     */
    'definitionName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceTO
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceTO
     */
    'endTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceTO
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceTO
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface Sort
 */
export interface Sort {
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    'sorted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    'unsorted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    'empty'?: boolean;
}
/**
 * 
 * @export
 * @interface StartInstanceTO
 */
export interface StartInstanceTO {
    /**
     * 
     * @type {string}
     * @memberof StartInstanceTO
     */
    'key'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof StartInstanceTO
     */
    'variables'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface StatusConfigTO
 */
export interface StatusConfigTO {
    /**
     * 
     * @type {string}
     * @memberof StatusConfigTO
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof StatusConfigTO
     */
    'label': string;
    /**
     * 
     * @type {number}
     * @memberof StatusConfigTO
     */
    'position': number;
}
/**
 * 
 * @export
 * @interface StatusDokumentTO
 */
export interface StatusDokumentTO {
    /**
     * 
     * @type {string}
     * @memberof StatusDokumentTO
     */
    'name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof StatusDokumentTO
     */
    'data'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UserTO
 */
export interface UserTO {
    /**
     * 
     * @type {string}
     * @memberof UserTO
     */
    'lhmObjectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserTO
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserTO
     */
    'forename'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserTO
     */
    'surname'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserTO
     */
    'ou'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserTO
     */
    'department'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserTO
     */
    'email'?: string;
}

/**
 * AlwDmsRestControllerApi - axios parameter creator
 * @export
 */
export const AlwDmsRestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {GetAlwMetadataTO} getAlwMetadataTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata: async (getAlwMetadataTO: GetAlwMetadataTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getAlwMetadataTO' is not null or undefined
            assertParamExists('getMetadata', 'getAlwMetadataTO', getAlwMetadataTO)
            const localVarPath = `/rest/alwdms/metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getAlwMetadataTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlwDmsRestControllerApi - functional programming interface
 * @export
 */
export const AlwDmsRestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AlwDmsRestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {GetAlwMetadataTO} getAlwMetadataTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadata(getAlwMetadataTO: GetAlwMetadataTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlwMetaDataTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetadata(getAlwMetadataTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AlwDmsRestControllerApi - factory interface
 * @export
 */
export const AlwDmsRestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AlwDmsRestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {GetAlwMetadataTO} getAlwMetadataTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata(getAlwMetadataTO: GetAlwMetadataTO, options?: any): AxiosPromise<AlwMetaDataTO> {
            return localVarFp.getMetadata(getAlwMetadataTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getMetadata operation in AlwDmsRestControllerApi.
 * @export
 * @interface AlwDmsRestControllerApiGetMetadataRequest
 */
export interface AlwDmsRestControllerApiGetMetadataRequest {
    /**
     * 
     * @type {GetAlwMetadataTO}
     * @memberof AlwDmsRestControllerApiGetMetadata
     */
    readonly getAlwMetadataTO: GetAlwMetadataTO
}

/**
 * AlwDmsRestControllerApi - object-oriented interface
 * @export
 * @class AlwDmsRestControllerApi
 * @extends {BaseAPI}
 */
export class AlwDmsRestControllerApi extends BaseAPI {
    /**
     * 
     * @param {AlwDmsRestControllerApiGetMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlwDmsRestControllerApi
     */
    public getMetadata(requestParameters: AlwDmsRestControllerApiGetMetadataRequest, options?: AxiosRequestConfig) {
        return AlwDmsRestControllerApiFp(this.configuration).getMetadata(requestParameters.getAlwMetadataTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeploymentControllerApi - axios parameter creator
 * @export
 */
export const DeploymentControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {DeploymentDto} deploymentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployArtifacts: async (deploymentDto: DeploymentDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deploymentDto' is not null or undefined
            assertParamExists('deployArtifacts', 'deploymentDto', deploymentDto)
            const localVarPath = `/rest/deployment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deploymentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeploymentControllerApi - functional programming interface
 * @export
 */
export const DeploymentControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeploymentControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {DeploymentDto} deploymentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployArtifacts(deploymentDto: DeploymentDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentStatusDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployArtifacts(deploymentDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeploymentControllerApi - factory interface
 * @export
 */
export const DeploymentControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeploymentControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {DeploymentDto} deploymentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployArtifacts(deploymentDto: DeploymentDto, options?: any): AxiosPromise<DeploymentStatusDto> {
            return localVarFp.deployArtifacts(deploymentDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deployArtifacts operation in DeploymentControllerApi.
 * @export
 * @interface DeploymentControllerApiDeployArtifactsRequest
 */
export interface DeploymentControllerApiDeployArtifactsRequest {
    /**
     * 
     * @type {DeploymentDto}
     * @memberof DeploymentControllerApiDeployArtifacts
     */
    readonly deploymentDto: DeploymentDto
}

/**
 * DeploymentControllerApi - object-oriented interface
 * @export
 * @class DeploymentControllerApi
 * @extends {BaseAPI}
 */
export class DeploymentControllerApi extends BaseAPI {
    /**
     * 
     * @param {DeploymentControllerApiDeployArtifactsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentControllerApi
     */
    public deployArtifacts(requestParameters: DeploymentControllerApiDeployArtifactsRequest, options?: AxiosRequestConfig) {
        return DeploymentControllerApiFp(this.configuration).deployArtifacts(requestParameters.deploymentDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DmsRestControllerApi - axios parameter creator
 * @export
 */
export const DmsRestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {GetMetadataTO} getMetadataTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetaData: async (getMetadataTO: GetMetadataTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getMetadataTO' is not null or undefined
            assertParamExists('getMetaData', 'getMetadataTO', getMetadataTO)
            const localVarPath = `/rest/dms/metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getMetadataTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DmsRestControllerApi - functional programming interface
 * @export
 */
export const DmsRestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DmsRestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {GetMetadataTO} getMetadataTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetaData(getMetadataTO: GetMetadataTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetadataTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetaData(getMetadataTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DmsRestControllerApi - factory interface
 * @export
 */
export const DmsRestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DmsRestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {GetMetadataTO} getMetadataTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetaData(getMetadataTO: GetMetadataTO, options?: any): AxiosPromise<MetadataTO> {
            return localVarFp.getMetaData(getMetadataTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getMetaData operation in DmsRestControllerApi.
 * @export
 * @interface DmsRestControllerApiGetMetaDataRequest
 */
export interface DmsRestControllerApiGetMetaDataRequest {
    /**
     * 
     * @type {GetMetadataTO}
     * @memberof DmsRestControllerApiGetMetaData
     */
    readonly getMetadataTO: GetMetadataTO
}

/**
 * DmsRestControllerApi - object-oriented interface
 * @export
 * @class DmsRestControllerApi
 * @extends {BaseAPI}
 */
export class DmsRestControllerApi extends BaseAPI {
    /**
     * 
     * @param {DmsRestControllerApiGetMetaDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DmsRestControllerApi
     */
    public getMetaData(requestParameters: DmsRestControllerApiGetMetaDataRequest, options?: AxiosRequestConfig) {
        return DmsRestControllerApiFp(this.configuration).getMetaData(requestParameters.getMetadataTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DocumentRestControllerApi - axios parameter creator
 * @export
 */
export const DocumentRestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusDokumentForTask: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getStatusDokumentForTask', 'id', id)
            const localVarPath = `/rest/document/task/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentRestControllerApi - functional programming interface
 * @export
 */
export const DocumentRestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentRestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatusDokumentForTask(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusDokumentTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatusDokumentForTask(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DocumentRestControllerApi - factory interface
 * @export
 */
export const DocumentRestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentRestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusDokumentForTask(id: string, options?: any): AxiosPromise<StatusDokumentTO> {
            return localVarFp.getStatusDokumentForTask(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getStatusDokumentForTask operation in DocumentRestControllerApi.
 * @export
 * @interface DocumentRestControllerApiGetStatusDokumentForTaskRequest
 */
export interface DocumentRestControllerApiGetStatusDokumentForTaskRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentRestControllerApiGetStatusDokumentForTask
     */
    readonly id: string
}

/**
 * DocumentRestControllerApi - object-oriented interface
 * @export
 * @class DocumentRestControllerApi
 * @extends {BaseAPI}
 */
export class DocumentRestControllerApi extends BaseAPI {
    /**
     * 
     * @param {DocumentRestControllerApiGetStatusDokumentForTaskRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentRestControllerApi
     */
    public getStatusDokumentForTask(requestParameters: DocumentRestControllerApiGetStatusDokumentForTaskRequest, options?: AxiosRequestConfig) {
        return DocumentRestControllerApiFp(this.configuration).getStatusDokumentForTask(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FilterRestControllerApi - axios parameter creator
 * @export
 */
export const FilterRestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('_delete', 'id', id)
            const localVarPath = `/rest/filter/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilters: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SaveFilterTO} saveFilterTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveFilter: async (saveFilterTO: SaveFilterTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'saveFilterTO' is not null or undefined
            assertParamExists('saveFilter', 'saveFilterTO', saveFilterTO)
            const localVarPath = `/rest/filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saveFilterTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilterRestControllerApi - functional programming interface
 * @export
 */
export const FilterRestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilterRestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFilters(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FilterTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFilters(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SaveFilterTO} saveFilterTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveFilter(saveFilterTO: SaveFilterTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilterTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveFilter(saveFilterTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FilterRestControllerApi - factory interface
 * @export
 */
export const FilterRestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilterRestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp._delete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilters(options?: any): AxiosPromise<Array<FilterTO>> {
            return localVarFp.getFilters(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SaveFilterTO} saveFilterTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveFilter(saveFilterTO: SaveFilterTO, options?: any): AxiosPromise<FilterTO> {
            return localVarFp.saveFilter(saveFilterTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for _delete operation in FilterRestControllerApi.
 * @export
 * @interface FilterRestControllerApiDeleteRequest
 */
export interface FilterRestControllerApiDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof FilterRestControllerApiDelete
     */
    readonly id: string
}

/**
 * Request parameters for saveFilter operation in FilterRestControllerApi.
 * @export
 * @interface FilterRestControllerApiSaveFilterRequest
 */
export interface FilterRestControllerApiSaveFilterRequest {
    /**
     * 
     * @type {SaveFilterTO}
     * @memberof FilterRestControllerApiSaveFilter
     */
    readonly saveFilterTO: SaveFilterTO
}

/**
 * FilterRestControllerApi - object-oriented interface
 * @export
 * @class FilterRestControllerApi
 * @extends {BaseAPI}
 */
export class FilterRestControllerApi extends BaseAPI {
    /**
     * 
     * @param {FilterRestControllerApiDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilterRestControllerApi
     */
    public _delete(requestParameters: FilterRestControllerApiDeleteRequest, options?: AxiosRequestConfig) {
        return FilterRestControllerApiFp(this.configuration)._delete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilterRestControllerApi
     */
    public getFilters(options?: AxiosRequestConfig) {
        return FilterRestControllerApiFp(this.configuration).getFilters(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FilterRestControllerApiSaveFilterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilterRestControllerApi
     */
    public saveFilter(requestParameters: FilterRestControllerApiSaveFilterRequest, options?: AxiosRequestConfig) {
        return FilterRestControllerApiFp(this.configuration).saveFilter(requestParameters.saveFilterTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FormRestControllerApi - axios parameter creator
 * @export
 */
export const FormRestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {FormTO} formTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createForm: async (formTO: FormTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'formTO' is not null or undefined
            assertParamExists('createForm', 'formTO', formTO)
            const localVarPath = `/rest/form`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(formTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForm: async (key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getForm', 'key', key)
            const localVarPath = `/rest/form/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForms: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/form`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} key 
         * @param {FormTO} formTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateForm: async (key: string, formTO: FormTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('updateForm', 'key', key)
            // verify required parameter 'formTO' is not null or undefined
            assertParamExists('updateForm', 'formTO', formTO)
            const localVarPath = `/rest/form/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(formTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FormRestControllerApi - functional programming interface
 * @export
 */
export const FormRestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FormRestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {FormTO} formTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createForm(formTO: FormTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FormTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createForm(formTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForm(key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FormTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForm(key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForms(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FormTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForms(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} key 
         * @param {FormTO} formTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateForm(key: string, formTO: FormTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FormTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateForm(key, formTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FormRestControllerApi - factory interface
 * @export
 */
export const FormRestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FormRestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {FormTO} formTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createForm(formTO: FormTO, options?: any): AxiosPromise<FormTO> {
            return localVarFp.createForm(formTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForm(key: string, options?: any): AxiosPromise<FormTO> {
            return localVarFp.getForm(key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForms(options?: any): AxiosPromise<Array<FormTO>> {
            return localVarFp.getForms(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} key 
         * @param {FormTO} formTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateForm(key: string, formTO: FormTO, options?: any): AxiosPromise<FormTO> {
            return localVarFp.updateForm(key, formTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createForm operation in FormRestControllerApi.
 * @export
 * @interface FormRestControllerApiCreateFormRequest
 */
export interface FormRestControllerApiCreateFormRequest {
    /**
     * 
     * @type {FormTO}
     * @memberof FormRestControllerApiCreateForm
     */
    readonly formTO: FormTO
}

/**
 * Request parameters for getForm operation in FormRestControllerApi.
 * @export
 * @interface FormRestControllerApiGetFormRequest
 */
export interface FormRestControllerApiGetFormRequest {
    /**
     * 
     * @type {string}
     * @memberof FormRestControllerApiGetForm
     */
    readonly key: string
}

/**
 * Request parameters for updateForm operation in FormRestControllerApi.
 * @export
 * @interface FormRestControllerApiUpdateFormRequest
 */
export interface FormRestControllerApiUpdateFormRequest {
    /**
     * 
     * @type {string}
     * @memberof FormRestControllerApiUpdateForm
     */
    readonly key: string

    /**
     * 
     * @type {FormTO}
     * @memberof FormRestControllerApiUpdateForm
     */
    readonly formTO: FormTO
}

/**
 * FormRestControllerApi - object-oriented interface
 * @export
 * @class FormRestControllerApi
 * @extends {BaseAPI}
 */
export class FormRestControllerApi extends BaseAPI {
    /**
     * 
     * @param {FormRestControllerApiCreateFormRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormRestControllerApi
     */
    public createForm(requestParameters: FormRestControllerApiCreateFormRequest, options?: AxiosRequestConfig) {
        return FormRestControllerApiFp(this.configuration).createForm(requestParameters.formTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FormRestControllerApiGetFormRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormRestControllerApi
     */
    public getForm(requestParameters: FormRestControllerApiGetFormRequest, options?: AxiosRequestConfig) {
        return FormRestControllerApiFp(this.configuration).getForm(requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormRestControllerApi
     */
    public getForms(options?: AxiosRequestConfig) {
        return FormRestControllerApiFp(this.configuration).getForms(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FormRestControllerApiUpdateFormRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormRestControllerApi
     */
    public updateForm(requestParameters: FormRestControllerApiUpdateFormRequest, options?: AxiosRequestConfig) {
        return FormRestControllerApiFp(this.configuration).updateForm(requestParameters.key, requestParameters.formTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HumanTaskFileRestControllerApi - axios parameter creator
 * @export
 */
export const HumanTaskFileRestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} taskId 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileNames: async (taskId: string, filePath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getFileNames', 'taskId', taskId)
            // verify required parameter 'filePath' is not null or undefined
            assertParamExists('getFileNames', 'filePath', filePath)
            const localVarPath = `/rest/task/file/{taskId}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)

            if (filePath !== undefined) {
                localVarQueryParameter['filePath'] = filePath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} taskId 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileDeletion: async (taskId: string, filename: string, filePath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getPresignedUrlForFileDeletion', 'taskId', taskId)
            // verify required parameter 'filename' is not null or undefined
            assertParamExists('getPresignedUrlForFileDeletion', 'filename', filename)
            // verify required parameter 'filePath' is not null or undefined
            assertParamExists('getPresignedUrlForFileDeletion', 'filePath', filePath)
            const localVarPath = `/rest/task/file/{taskId}/{filename}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)))
                .replace(`{${"filename"}}`, encodeURIComponent(String(filename)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)

            if (filePath !== undefined) {
                localVarQueryParameter['filePath'] = filePath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} taskId 
         * @param {string} fileName 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileDownload: async (taskId: string, fileName: string, filePath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getPresignedUrlForFileDownload', 'taskId', taskId)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('getPresignedUrlForFileDownload', 'fileName', fileName)
            // verify required parameter 'filePath' is not null or undefined
            assertParamExists('getPresignedUrlForFileDownload', 'filePath', filePath)
            const localVarPath = `/rest/task/file/{taskId}/{fileName}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)))
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)

            if (filePath !== undefined) {
                localVarQueryParameter['filePath'] = filePath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} taskId 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileUpload: async (taskId: string, filename: string, filePath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getPresignedUrlForFileUpload', 'taskId', taskId)
            // verify required parameter 'filename' is not null or undefined
            assertParamExists('getPresignedUrlForFileUpload', 'filename', filename)
            // verify required parameter 'filePath' is not null or undefined
            assertParamExists('getPresignedUrlForFileUpload', 'filePath', filePath)
            const localVarPath = `/rest/task/file/{taskId}/{filename}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)))
                .replace(`{${"filename"}}`, encodeURIComponent(String(filename)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)

            if (filePath !== undefined) {
                localVarQueryParameter['filePath'] = filePath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HumanTaskFileRestControllerApi - functional programming interface
 * @export
 */
export const HumanTaskFileRestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HumanTaskFileRestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} taskId 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileNames(taskId: string, filePath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileNames(taskId, filePath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} taskId 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPresignedUrlForFileDeletion(taskId: string, filename: string, filePath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPresignedUrlForFileDeletion(taskId, filename, filePath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} taskId 
         * @param {string} fileName 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPresignedUrlForFileDownload(taskId: string, fileName: string, filePath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPresignedUrlForFileDownload(taskId, fileName, filePath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} taskId 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPresignedUrlForFileUpload(taskId: string, filename: string, filePath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPresignedUrlForFileUpload(taskId, filename, filePath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HumanTaskFileRestControllerApi - factory interface
 * @export
 */
export const HumanTaskFileRestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HumanTaskFileRestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} taskId 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileNames(taskId: string, filePath: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getFileNames(taskId, filePath, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} taskId 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileDeletion(taskId: string, filename: string, filePath: string, options?: any): AxiosPromise<string> {
            return localVarFp.getPresignedUrlForFileDeletion(taskId, filename, filePath, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} taskId 
         * @param {string} fileName 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileDownload(taskId: string, fileName: string, filePath: string, options?: any): AxiosPromise<string> {
            return localVarFp.getPresignedUrlForFileDownload(taskId, fileName, filePath, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} taskId 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileUpload(taskId: string, filename: string, filePath: string, options?: any): AxiosPromise<string> {
            return localVarFp.getPresignedUrlForFileUpload(taskId, filename, filePath, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getFileNames operation in HumanTaskFileRestControllerApi.
 * @export
 * @interface HumanTaskFileRestControllerApiGetFileNamesRequest
 */
export interface HumanTaskFileRestControllerApiGetFileNamesRequest {
    /**
     * 
     * @type {string}
     * @memberof HumanTaskFileRestControllerApiGetFileNames
     */
    readonly taskId: string

    /**
     * 
     * @type {string}
     * @memberof HumanTaskFileRestControllerApiGetFileNames
     */
    readonly filePath: string
}

/**
 * Request parameters for getPresignedUrlForFileDeletion operation in HumanTaskFileRestControllerApi.
 * @export
 * @interface HumanTaskFileRestControllerApiGetPresignedUrlForFileDeletionRequest
 */
export interface HumanTaskFileRestControllerApiGetPresignedUrlForFileDeletionRequest {
    /**
     * 
     * @type {string}
     * @memberof HumanTaskFileRestControllerApiGetPresignedUrlForFileDeletion
     */
    readonly taskId: string

    /**
     * 
     * @type {string}
     * @memberof HumanTaskFileRestControllerApiGetPresignedUrlForFileDeletion
     */
    readonly filename: string

    /**
     * 
     * @type {string}
     * @memberof HumanTaskFileRestControllerApiGetPresignedUrlForFileDeletion
     */
    readonly filePath: string
}

/**
 * Request parameters for getPresignedUrlForFileDownload operation in HumanTaskFileRestControllerApi.
 * @export
 * @interface HumanTaskFileRestControllerApiGetPresignedUrlForFileDownloadRequest
 */
export interface HumanTaskFileRestControllerApiGetPresignedUrlForFileDownloadRequest {
    /**
     * 
     * @type {string}
     * @memberof HumanTaskFileRestControllerApiGetPresignedUrlForFileDownload
     */
    readonly taskId: string

    /**
     * 
     * @type {string}
     * @memberof HumanTaskFileRestControllerApiGetPresignedUrlForFileDownload
     */
    readonly fileName: string

    /**
     * 
     * @type {string}
     * @memberof HumanTaskFileRestControllerApiGetPresignedUrlForFileDownload
     */
    readonly filePath: string
}

/**
 * Request parameters for getPresignedUrlForFileUpload operation in HumanTaskFileRestControllerApi.
 * @export
 * @interface HumanTaskFileRestControllerApiGetPresignedUrlForFileUploadRequest
 */
export interface HumanTaskFileRestControllerApiGetPresignedUrlForFileUploadRequest {
    /**
     * 
     * @type {string}
     * @memberof HumanTaskFileRestControllerApiGetPresignedUrlForFileUpload
     */
    readonly taskId: string

    /**
     * 
     * @type {string}
     * @memberof HumanTaskFileRestControllerApiGetPresignedUrlForFileUpload
     */
    readonly filename: string

    /**
     * 
     * @type {string}
     * @memberof HumanTaskFileRestControllerApiGetPresignedUrlForFileUpload
     */
    readonly filePath: string
}

/**
 * HumanTaskFileRestControllerApi - object-oriented interface
 * @export
 * @class HumanTaskFileRestControllerApi
 * @extends {BaseAPI}
 */
export class HumanTaskFileRestControllerApi extends BaseAPI {
    /**
     * 
     * @param {HumanTaskFileRestControllerApiGetFileNamesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HumanTaskFileRestControllerApi
     */
    public getFileNames(requestParameters: HumanTaskFileRestControllerApiGetFileNamesRequest, options?: AxiosRequestConfig) {
        return HumanTaskFileRestControllerApiFp(this.configuration).getFileNames(requestParameters.taskId, requestParameters.filePath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {HumanTaskFileRestControllerApiGetPresignedUrlForFileDeletionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HumanTaskFileRestControllerApi
     */
    public getPresignedUrlForFileDeletion(requestParameters: HumanTaskFileRestControllerApiGetPresignedUrlForFileDeletionRequest, options?: AxiosRequestConfig) {
        return HumanTaskFileRestControllerApiFp(this.configuration).getPresignedUrlForFileDeletion(requestParameters.taskId, requestParameters.filename, requestParameters.filePath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {HumanTaskFileRestControllerApiGetPresignedUrlForFileDownloadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HumanTaskFileRestControllerApi
     */
    public getPresignedUrlForFileDownload(requestParameters: HumanTaskFileRestControllerApiGetPresignedUrlForFileDownloadRequest, options?: AxiosRequestConfig) {
        return HumanTaskFileRestControllerApiFp(this.configuration).getPresignedUrlForFileDownload(requestParameters.taskId, requestParameters.fileName, requestParameters.filePath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {HumanTaskFileRestControllerApiGetPresignedUrlForFileUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HumanTaskFileRestControllerApi
     */
    public getPresignedUrlForFileUpload(requestParameters: HumanTaskFileRestControllerApiGetPresignedUrlForFileUploadRequest, options?: AxiosRequestConfig) {
        return HumanTaskFileRestControllerApiFp(this.configuration).getPresignedUrlForFileUpload(requestParameters.taskId, requestParameters.filename, requestParameters.filePath, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HumanTaskRestControllerApi - axios parameter creator
 * @export
 */
export const HumanTaskRestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignTask: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('assignTask', 'id', id)
            const localVarPath = `/rest/task/assign/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTask: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancelTask', 'id', id)
            const localVarPath = `/rest/task/cancel/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CompleteTO} completeTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTask: async (completeTO: CompleteTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'completeTO' is not null or undefined
            assertParamExists('completeTask', 'completeTO', completeTO)
            const localVarPath = `/rest/task`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(completeTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FollowUpTO} followUpTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followUpTask: async (followUpTO: FollowUpTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'followUpTO' is not null or undefined
            assertParamExists('followUpTask', 'followUpTO', followUpTO)
            const localVarPath = `/rest/task/followup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(followUpTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssignedGroupTasks: async (page?: number, size?: number, query?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/task/group/assigned`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenGroupTasks: async (page?: number, size?: number, query?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/task/group/open`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskDetail: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTaskDetail', 'id', id)
            const localVarPath = `/rest/task/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {boolean} [followUp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks: async (page?: number, size?: number, query?: string, followUp?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/task`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (followUp !== undefined) {
                localVarQueryParameter['followUp'] = followUp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SaveTO} saveTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTask: async (saveTO: SaveTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'saveTO' is not null or undefined
            assertParamExists('saveTask', 'saveTO', saveTO)
            const localVarPath = `/rest/task`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saveTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HumanTaskRestControllerApi - functional programming interface
 * @export
 */
export const HumanTaskRestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HumanTaskRestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignTask(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignTask(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelTask(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelTask(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CompleteTO} completeTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeTask(completeTO: CompleteTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeTask(completeTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {FollowUpTO} followUpTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followUpTask(followUpTO: FollowUpTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followUpTask(followUpTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssignedGroupTasks(page?: number, size?: number, query?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageHumanTaskTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssignedGroupTasks(page, size, query, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOpenGroupTasks(page?: number, size?: number, query?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageHumanTaskTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOpenGroupTasks(page, size, query, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskDetail(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HumanTaskDetailTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskDetail(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {boolean} [followUp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTasks(page?: number, size?: number, query?: string, followUp?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageHumanTaskTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTasks(page, size, query, followUp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SaveTO} saveTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveTask(saveTO: SaveTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveTask(saveTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HumanTaskRestControllerApi - factory interface
 * @export
 */
export const HumanTaskRestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HumanTaskRestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignTask(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.assignTask(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTask(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.cancelTask(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CompleteTO} completeTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTask(completeTO: CompleteTO, options?: any): AxiosPromise<void> {
            return localVarFp.completeTask(completeTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FollowUpTO} followUpTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followUpTask(followUpTO: FollowUpTO, options?: any): AxiosPromise<void> {
            return localVarFp.followUpTask(followUpTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssignedGroupTasks(page?: number, size?: number, query?: string, options?: any): AxiosPromise<PageHumanTaskTO> {
            return localVarFp.getAssignedGroupTasks(page, size, query, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenGroupTasks(page?: number, size?: number, query?: string, options?: any): AxiosPromise<PageHumanTaskTO> {
            return localVarFp.getOpenGroupTasks(page, size, query, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskDetail(id: string, options?: any): AxiosPromise<HumanTaskDetailTO> {
            return localVarFp.getTaskDetail(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {boolean} [followUp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks(page?: number, size?: number, query?: string, followUp?: boolean, options?: any): AxiosPromise<PageHumanTaskTO> {
            return localVarFp.getTasks(page, size, query, followUp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SaveTO} saveTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTask(saveTO: SaveTO, options?: any): AxiosPromise<void> {
            return localVarFp.saveTask(saveTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for assignTask operation in HumanTaskRestControllerApi.
 * @export
 * @interface HumanTaskRestControllerApiAssignTaskRequest
 */
export interface HumanTaskRestControllerApiAssignTaskRequest {
    /**
     * 
     * @type {string}
     * @memberof HumanTaskRestControllerApiAssignTask
     */
    readonly id: string
}

/**
 * Request parameters for cancelTask operation in HumanTaskRestControllerApi.
 * @export
 * @interface HumanTaskRestControllerApiCancelTaskRequest
 */
export interface HumanTaskRestControllerApiCancelTaskRequest {
    /**
     * 
     * @type {string}
     * @memberof HumanTaskRestControllerApiCancelTask
     */
    readonly id: string
}

/**
 * Request parameters for completeTask operation in HumanTaskRestControllerApi.
 * @export
 * @interface HumanTaskRestControllerApiCompleteTaskRequest
 */
export interface HumanTaskRestControllerApiCompleteTaskRequest {
    /**
     * 
     * @type {CompleteTO}
     * @memberof HumanTaskRestControllerApiCompleteTask
     */
    readonly completeTO: CompleteTO
}

/**
 * Request parameters for followUpTask operation in HumanTaskRestControllerApi.
 * @export
 * @interface HumanTaskRestControllerApiFollowUpTaskRequest
 */
export interface HumanTaskRestControllerApiFollowUpTaskRequest {
    /**
     * 
     * @type {FollowUpTO}
     * @memberof HumanTaskRestControllerApiFollowUpTask
     */
    readonly followUpTO: FollowUpTO
}

/**
 * Request parameters for getAssignedGroupTasks operation in HumanTaskRestControllerApi.
 * @export
 * @interface HumanTaskRestControllerApiGetAssignedGroupTasksRequest
 */
export interface HumanTaskRestControllerApiGetAssignedGroupTasksRequest {
    /**
     * 
     * @type {number}
     * @memberof HumanTaskRestControllerApiGetAssignedGroupTasks
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof HumanTaskRestControllerApiGetAssignedGroupTasks
     */
    readonly size?: number

    /**
     * 
     * @type {string}
     * @memberof HumanTaskRestControllerApiGetAssignedGroupTasks
     */
    readonly query?: string
}

/**
 * Request parameters for getOpenGroupTasks operation in HumanTaskRestControllerApi.
 * @export
 * @interface HumanTaskRestControllerApiGetOpenGroupTasksRequest
 */
export interface HumanTaskRestControllerApiGetOpenGroupTasksRequest {
    /**
     * 
     * @type {number}
     * @memberof HumanTaskRestControllerApiGetOpenGroupTasks
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof HumanTaskRestControllerApiGetOpenGroupTasks
     */
    readonly size?: number

    /**
     * 
     * @type {string}
     * @memberof HumanTaskRestControllerApiGetOpenGroupTasks
     */
    readonly query?: string
}

/**
 * Request parameters for getTaskDetail operation in HumanTaskRestControllerApi.
 * @export
 * @interface HumanTaskRestControllerApiGetTaskDetailRequest
 */
export interface HumanTaskRestControllerApiGetTaskDetailRequest {
    /**
     * 
     * @type {string}
     * @memberof HumanTaskRestControllerApiGetTaskDetail
     */
    readonly id: string
}

/**
 * Request parameters for getTasks operation in HumanTaskRestControllerApi.
 * @export
 * @interface HumanTaskRestControllerApiGetTasksRequest
 */
export interface HumanTaskRestControllerApiGetTasksRequest {
    /**
     * 
     * @type {number}
     * @memberof HumanTaskRestControllerApiGetTasks
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof HumanTaskRestControllerApiGetTasks
     */
    readonly size?: number

    /**
     * 
     * @type {string}
     * @memberof HumanTaskRestControllerApiGetTasks
     */
    readonly query?: string

    /**
     * 
     * @type {boolean}
     * @memberof HumanTaskRestControllerApiGetTasks
     */
    readonly followUp?: boolean
}

/**
 * Request parameters for saveTask operation in HumanTaskRestControllerApi.
 * @export
 * @interface HumanTaskRestControllerApiSaveTaskRequest
 */
export interface HumanTaskRestControllerApiSaveTaskRequest {
    /**
     * 
     * @type {SaveTO}
     * @memberof HumanTaskRestControllerApiSaveTask
     */
    readonly saveTO: SaveTO
}

/**
 * HumanTaskRestControllerApi - object-oriented interface
 * @export
 * @class HumanTaskRestControllerApi
 * @extends {BaseAPI}
 */
export class HumanTaskRestControllerApi extends BaseAPI {
    /**
     * 
     * @param {HumanTaskRestControllerApiAssignTaskRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HumanTaskRestControllerApi
     */
    public assignTask(requestParameters: HumanTaskRestControllerApiAssignTaskRequest, options?: AxiosRequestConfig) {
        return HumanTaskRestControllerApiFp(this.configuration).assignTask(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {HumanTaskRestControllerApiCancelTaskRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HumanTaskRestControllerApi
     */
    public cancelTask(requestParameters: HumanTaskRestControllerApiCancelTaskRequest, options?: AxiosRequestConfig) {
        return HumanTaskRestControllerApiFp(this.configuration).cancelTask(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {HumanTaskRestControllerApiCompleteTaskRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HumanTaskRestControllerApi
     */
    public completeTask(requestParameters: HumanTaskRestControllerApiCompleteTaskRequest, options?: AxiosRequestConfig) {
        return HumanTaskRestControllerApiFp(this.configuration).completeTask(requestParameters.completeTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {HumanTaskRestControllerApiFollowUpTaskRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HumanTaskRestControllerApi
     */
    public followUpTask(requestParameters: HumanTaskRestControllerApiFollowUpTaskRequest, options?: AxiosRequestConfig) {
        return HumanTaskRestControllerApiFp(this.configuration).followUpTask(requestParameters.followUpTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {HumanTaskRestControllerApiGetAssignedGroupTasksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HumanTaskRestControllerApi
     */
    public getAssignedGroupTasks(requestParameters: HumanTaskRestControllerApiGetAssignedGroupTasksRequest = {}, options?: AxiosRequestConfig) {
        return HumanTaskRestControllerApiFp(this.configuration).getAssignedGroupTasks(requestParameters.page, requestParameters.size, requestParameters.query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {HumanTaskRestControllerApiGetOpenGroupTasksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HumanTaskRestControllerApi
     */
    public getOpenGroupTasks(requestParameters: HumanTaskRestControllerApiGetOpenGroupTasksRequest = {}, options?: AxiosRequestConfig) {
        return HumanTaskRestControllerApiFp(this.configuration).getOpenGroupTasks(requestParameters.page, requestParameters.size, requestParameters.query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {HumanTaskRestControllerApiGetTaskDetailRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HumanTaskRestControllerApi
     */
    public getTaskDetail(requestParameters: HumanTaskRestControllerApiGetTaskDetailRequest, options?: AxiosRequestConfig) {
        return HumanTaskRestControllerApiFp(this.configuration).getTaskDetail(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {HumanTaskRestControllerApiGetTasksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HumanTaskRestControllerApi
     */
    public getTasks(requestParameters: HumanTaskRestControllerApiGetTasksRequest = {}, options?: AxiosRequestConfig) {
        return HumanTaskRestControllerApiFp(this.configuration).getTasks(requestParameters.page, requestParameters.size, requestParameters.query, requestParameters.followUp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {HumanTaskRestControllerApiSaveTaskRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HumanTaskRestControllerApi
     */
    public saveTask(requestParameters: HumanTaskRestControllerApiSaveTaskRequest, options?: AxiosRequestConfig) {
        return HumanTaskRestControllerApiFp(this.configuration).saveTask(requestParameters.saveTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InfoRestControllerApi - axios parameter creator
 * @export
 */
export const InfoRestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InfoRestControllerApi - functional programming interface
 * @export
 */
export const InfoRestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InfoRestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InfoTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InfoRestControllerApi - factory interface
 * @export
 */
export const InfoRestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InfoRestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo(options?: any): AxiosPromise<InfoTO> {
            return localVarFp.getInfo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InfoRestControllerApi - object-oriented interface
 * @export
 * @class InfoRestControllerApi
 * @extends {BaseAPI}
 */
export class InfoRestControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfoRestControllerApi
     */
    public getInfo(options?: AxiosRequestConfig) {
        return InfoRestControllerApiFp(this.configuration).getInfo(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MessageControllerApi - axios parameter creator
 * @export
 */
export const MessageControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {SendMessageTO} sendMessageTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessage: async (sendMessageTO: SendMessageTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendMessageTO' is not null or undefined
            assertParamExists('sendMessage', 'sendMessageTO', sendMessageTO)
            const localVarPath = `/rest/input/message/send/message`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendMessageTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessageControllerApi - functional programming interface
 * @export
 */
export const MessageControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MessageControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {SendMessageTO} sendMessageTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendMessage(sendMessageTO: SendMessageTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendMessage(sendMessageTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MessageControllerApi - factory interface
 * @export
 */
export const MessageControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MessageControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {SendMessageTO} sendMessageTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessage(sendMessageTO: SendMessageTO, options?: any): AxiosPromise<void> {
            return localVarFp.sendMessage(sendMessageTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for sendMessage operation in MessageControllerApi.
 * @export
 * @interface MessageControllerApiSendMessageRequest
 */
export interface MessageControllerApiSendMessageRequest {
    /**
     * 
     * @type {SendMessageTO}
     * @memberof MessageControllerApiSendMessage
     */
    readonly sendMessageTO: SendMessageTO
}

/**
 * MessageControllerApi - object-oriented interface
 * @export
 * @class MessageControllerApi
 * @extends {BaseAPI}
 */
export class MessageControllerApi extends BaseAPI {
    /**
     * 
     * @param {MessageControllerApiSendMessageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageControllerApi
     */
    public sendMessage(requestParameters: MessageControllerApiSendMessageRequest, options?: AxiosRequestConfig) {
        return MessageControllerApiFp(this.configuration).sendMessage(requestParameters.sendMessageTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProcessConfigurationControllerApi - axios parameter creator
 * @export
 */
export const ProcessConfigurationControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ProcessConfigTO} processConfigTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConfig: async (processConfigTO: ProcessConfigTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'processConfigTO' is not null or undefined
            assertParamExists('createConfig', 'processConfigTO', processConfigTO)
            const localVarPath = `/rest/processconfig`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(processConfigTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig: async (key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getConfig', 'key', key)
            const localVarPath = `/rest/processconfig/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProcessConfigurationControllerApi - functional programming interface
 * @export
 */
export const ProcessConfigurationControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProcessConfigurationControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ProcessConfigTO} processConfigTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConfig(processConfigTO: ProcessConfigTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessConfigTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConfig(processConfigTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfig(key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessConfigTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfig(key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProcessConfigurationControllerApi - factory interface
 * @export
 */
export const ProcessConfigurationControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProcessConfigurationControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {ProcessConfigTO} processConfigTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConfig(processConfigTO: ProcessConfigTO, options?: any): AxiosPromise<ProcessConfigTO> {
            return localVarFp.createConfig(processConfigTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig(key: string, options?: any): AxiosPromise<ProcessConfigTO> {
            return localVarFp.getConfig(key, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createConfig operation in ProcessConfigurationControllerApi.
 * @export
 * @interface ProcessConfigurationControllerApiCreateConfigRequest
 */
export interface ProcessConfigurationControllerApiCreateConfigRequest {
    /**
     * 
     * @type {ProcessConfigTO}
     * @memberof ProcessConfigurationControllerApiCreateConfig
     */
    readonly processConfigTO: ProcessConfigTO
}

/**
 * Request parameters for getConfig operation in ProcessConfigurationControllerApi.
 * @export
 * @interface ProcessConfigurationControllerApiGetConfigRequest
 */
export interface ProcessConfigurationControllerApiGetConfigRequest {
    /**
     * 
     * @type {string}
     * @memberof ProcessConfigurationControllerApiGetConfig
     */
    readonly key: string
}

/**
 * ProcessConfigurationControllerApi - object-oriented interface
 * @export
 * @class ProcessConfigurationControllerApi
 * @extends {BaseAPI}
 */
export class ProcessConfigurationControllerApi extends BaseAPI {
    /**
     * 
     * @param {ProcessConfigurationControllerApiCreateConfigRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessConfigurationControllerApi
     */
    public createConfig(requestParameters: ProcessConfigurationControllerApiCreateConfigRequest, options?: AxiosRequestConfig) {
        return ProcessConfigurationControllerApiFp(this.configuration).createConfig(requestParameters.processConfigTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ProcessConfigurationControllerApiGetConfigRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessConfigurationControllerApi
     */
    public getConfig(requestParameters: ProcessConfigurationControllerApiGetConfigRequest, options?: AxiosRequestConfig) {
        return ProcessConfigurationControllerApiFp(this.configuration).getConfig(requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SchemaRestControllerApi - axios parameter creator
 * @export
 */
export const SchemaRestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * create a new json schema
         * @param {JsonSchemaTO} jsonSchemaTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJsonSchema: async (jsonSchemaTO: JsonSchemaTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jsonSchemaTO' is not null or undefined
            assertParamExists('createJsonSchema', 'jsonSchemaTO', jsonSchemaTO)
            const localVarPath = `/rest/jsonschema`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonSchemaTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get json schema by key
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJsonSchema: async (key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getJsonSchema', 'key', key)
            const localVarPath = `/rest/jsonschema/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchemaRestControllerApi - functional programming interface
 * @export
 */
export const SchemaRestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchemaRestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * create a new json schema
         * @param {JsonSchemaTO} jsonSchemaTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJsonSchema(jsonSchemaTO: JsonSchemaTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSchemaTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createJsonSchema(jsonSchemaTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get json schema by key
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJsonSchema(key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSchemaTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJsonSchema(key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SchemaRestControllerApi - factory interface
 * @export
 */
export const SchemaRestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchemaRestControllerApiFp(configuration)
    return {
        /**
         * create a new json schema
         * @param {JsonSchemaTO} jsonSchemaTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJsonSchema(jsonSchemaTO: JsonSchemaTO, options?: any): AxiosPromise<JsonSchemaTO> {
            return localVarFp.createJsonSchema(jsonSchemaTO, options).then((request) => request(axios, basePath));
        },
        /**
         * get json schema by key
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJsonSchema(key: string, options?: any): AxiosPromise<JsonSchemaTO> {
            return localVarFp.getJsonSchema(key, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createJsonSchema operation in SchemaRestControllerApi.
 * @export
 * @interface SchemaRestControllerApiCreateJsonSchemaRequest
 */
export interface SchemaRestControllerApiCreateJsonSchemaRequest {
    /**
     * 
     * @type {JsonSchemaTO}
     * @memberof SchemaRestControllerApiCreateJsonSchema
     */
    readonly jsonSchemaTO: JsonSchemaTO
}

/**
 * Request parameters for getJsonSchema operation in SchemaRestControllerApi.
 * @export
 * @interface SchemaRestControllerApiGetJsonSchemaRequest
 */
export interface SchemaRestControllerApiGetJsonSchemaRequest {
    /**
     * 
     * @type {string}
     * @memberof SchemaRestControllerApiGetJsonSchema
     */
    readonly key: string
}

/**
 * SchemaRestControllerApi - object-oriented interface
 * @export
 * @class SchemaRestControllerApi
 * @extends {BaseAPI}
 */
export class SchemaRestControllerApi extends BaseAPI {
    /**
     * create a new json schema
     * @param {SchemaRestControllerApiCreateJsonSchemaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaRestControllerApi
     */
    public createJsonSchema(requestParameters: SchemaRestControllerApiCreateJsonSchemaRequest, options?: AxiosRequestConfig) {
        return SchemaRestControllerApiFp(this.configuration).createJsonSchema(requestParameters.jsonSchemaTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get json schema by key
     * @param {SchemaRestControllerApiGetJsonSchemaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaRestControllerApi
     */
    public getJsonSchema(requestParameters: SchemaRestControllerApiGetJsonSchemaRequest, options?: AxiosRequestConfig) {
        return SchemaRestControllerApiFp(this.configuration).getJsonSchema(requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServiceDefinitionControllerApi - axios parameter creator
 * @export
 */
export const ServiceDefinitionControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a specific service definition
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDefinition: async (key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getServiceDefinition', 'key', key)
            const localVarPath = `/rest/service/definition/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * load all available service definitions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDefinitions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/service/definition`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a specific service
         * @param {StartInstanceTO} startInstanceTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startInstance: async (startInstanceTO: StartInstanceTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startInstanceTO' is not null or undefined
            assertParamExists('startInstance', 'startInstanceTO', startInstanceTO)
            const localVarPath = `/rest/service/definition`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(startInstanceTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceDefinitionControllerApi - functional programming interface
 * @export
 */
export const ServiceDefinitionControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceDefinitionControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a specific service definition
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceDefinition(key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceDefinitionDetailTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceDefinition(key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * load all available service definitions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceDefinitions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServiceDefinitionTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceDefinitions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Start a specific service
         * @param {StartInstanceTO} startInstanceTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startInstance(startInstanceTO: StartInstanceTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startInstance(startInstanceTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServiceDefinitionControllerApi - factory interface
 * @export
 */
export const ServiceDefinitionControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceDefinitionControllerApiFp(configuration)
    return {
        /**
         * Get a specific service definition
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDefinition(key: string, options?: any): AxiosPromise<ServiceDefinitionDetailTO> {
            return localVarFp.getServiceDefinition(key, options).then((request) => request(axios, basePath));
        },
        /**
         * load all available service definitions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDefinitions(options?: any): AxiosPromise<Array<ServiceDefinitionTO>> {
            return localVarFp.getServiceDefinitions(options).then((request) => request(axios, basePath));
        },
        /**
         * Start a specific service
         * @param {StartInstanceTO} startInstanceTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startInstance(startInstanceTO: StartInstanceTO, options?: any): AxiosPromise<void> {
            return localVarFp.startInstance(startInstanceTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getServiceDefinition operation in ServiceDefinitionControllerApi.
 * @export
 * @interface ServiceDefinitionControllerApiGetServiceDefinitionRequest
 */
export interface ServiceDefinitionControllerApiGetServiceDefinitionRequest {
    /**
     * 
     * @type {string}
     * @memberof ServiceDefinitionControllerApiGetServiceDefinition
     */
    readonly key: string
}

/**
 * Request parameters for startInstance operation in ServiceDefinitionControllerApi.
 * @export
 * @interface ServiceDefinitionControllerApiStartInstanceRequest
 */
export interface ServiceDefinitionControllerApiStartInstanceRequest {
    /**
     * 
     * @type {StartInstanceTO}
     * @memberof ServiceDefinitionControllerApiStartInstance
     */
    readonly startInstanceTO: StartInstanceTO
}

/**
 * ServiceDefinitionControllerApi - object-oriented interface
 * @export
 * @class ServiceDefinitionControllerApi
 * @extends {BaseAPI}
 */
export class ServiceDefinitionControllerApi extends BaseAPI {
    /**
     * Get a specific service definition
     * @param {ServiceDefinitionControllerApiGetServiceDefinitionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDefinitionControllerApi
     */
    public getServiceDefinition(requestParameters: ServiceDefinitionControllerApiGetServiceDefinitionRequest, options?: AxiosRequestConfig) {
        return ServiceDefinitionControllerApiFp(this.configuration).getServiceDefinition(requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * load all available service definitions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDefinitionControllerApi
     */
    public getServiceDefinitions(options?: AxiosRequestConfig) {
        return ServiceDefinitionControllerApiFp(this.configuration).getServiceDefinitions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a specific service
     * @param {ServiceDefinitionControllerApiStartInstanceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDefinitionControllerApi
     */
    public startInstance(requestParameters: ServiceDefinitionControllerApiStartInstanceRequest, options?: AxiosRequestConfig) {
        return ServiceDefinitionControllerApiFp(this.configuration).startInstance(requestParameters.startInstanceTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServiceInstanceControllerApi - axios parameter creator
 * @export
 */
export const ServiceInstanceControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssignedInstances: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/service/instance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstanceDetail: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProcessInstanceDetail', 'id', id)
            const localVarPath = `/rest/service/instance/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceInstanceControllerApi - functional programming interface
 * @export
 */
export const ServiceInstanceControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceInstanceControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssignedInstances(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServiceInstanceTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssignedInstances(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessInstanceDetail(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceInstanceDetailTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessInstanceDetail(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServiceInstanceControllerApi - factory interface
 * @export
 */
export const ServiceInstanceControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceInstanceControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssignedInstances(options?: any): AxiosPromise<Array<ServiceInstanceTO>> {
            return localVarFp.getAssignedInstances(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstanceDetail(id: string, options?: any): AxiosPromise<ServiceInstanceDetailTO> {
            return localVarFp.getProcessInstanceDetail(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getProcessInstanceDetail operation in ServiceInstanceControllerApi.
 * @export
 * @interface ServiceInstanceControllerApiGetProcessInstanceDetailRequest
 */
export interface ServiceInstanceControllerApiGetProcessInstanceDetailRequest {
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceControllerApiGetProcessInstanceDetail
     */
    readonly id: string
}

/**
 * ServiceInstanceControllerApi - object-oriented interface
 * @export
 * @class ServiceInstanceControllerApi
 * @extends {BaseAPI}
 */
export class ServiceInstanceControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceInstanceControllerApi
     */
    public getAssignedInstances(options?: AxiosRequestConfig) {
        return ServiceInstanceControllerApiFp(this.configuration).getAssignedInstances(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ServiceInstanceControllerApiGetProcessInstanceDetailRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceInstanceControllerApi
     */
    public getProcessInstanceDetail(requestParameters: ServiceInstanceControllerApiGetProcessInstanceDetailRequest, options?: AxiosRequestConfig) {
        return ServiceInstanceControllerApiFp(this.configuration).getProcessInstanceDetail(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServiceInstanceFileRestControllerApi - axios parameter creator
 * @export
 */
export const ServiceInstanceFileRestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} instanceId 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileNames2: async (instanceId: string, filePath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('getFileNames2', 'instanceId', instanceId)
            // verify required parameter 'filePath' is not null or undefined
            assertParamExists('getFileNames2', 'filePath', filePath)
            const localVarPath = `/rest/service/instance/file/{instanceId}`
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)

            if (filePath !== undefined) {
                localVarQueryParameter['filePath'] = filePath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceId 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileDeletion2: async (instanceId: string, filename: string, filePath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('getPresignedUrlForFileDeletion2', 'instanceId', instanceId)
            // verify required parameter 'filename' is not null or undefined
            assertParamExists('getPresignedUrlForFileDeletion2', 'filename', filename)
            // verify required parameter 'filePath' is not null or undefined
            assertParamExists('getPresignedUrlForFileDeletion2', 'filePath', filePath)
            const localVarPath = `/rest/service/instance/file/{instanceId}/{filename}`
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"filename"}}`, encodeURIComponent(String(filename)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)

            if (filePath !== undefined) {
                localVarQueryParameter['filePath'] = filePath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceId 
         * @param {string} fileName 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileDownload2: async (instanceId: string, fileName: string, filePath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('getPresignedUrlForFileDownload2', 'instanceId', instanceId)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('getPresignedUrlForFileDownload2', 'fileName', fileName)
            // verify required parameter 'filePath' is not null or undefined
            assertParamExists('getPresignedUrlForFileDownload2', 'filePath', filePath)
            const localVarPath = `/rest/service/instance/file/{instanceId}/{fileName}`
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)

            if (filePath !== undefined) {
                localVarQueryParameter['filePath'] = filePath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceId 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileUpload2: async (instanceId: string, filename: string, filePath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('getPresignedUrlForFileUpload2', 'instanceId', instanceId)
            // verify required parameter 'filename' is not null or undefined
            assertParamExists('getPresignedUrlForFileUpload2', 'filename', filename)
            // verify required parameter 'filePath' is not null or undefined
            assertParamExists('getPresignedUrlForFileUpload2', 'filePath', filePath)
            const localVarPath = `/rest/service/instance/file/{instanceId}/{filename}`
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"filename"}}`, encodeURIComponent(String(filename)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)

            if (filePath !== undefined) {
                localVarQueryParameter['filePath'] = filePath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceInstanceFileRestControllerApi - functional programming interface
 * @export
 */
export const ServiceInstanceFileRestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceInstanceFileRestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} instanceId 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileNames2(instanceId: string, filePath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileNames2(instanceId, filePath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} instanceId 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPresignedUrlForFileDeletion2(instanceId: string, filename: string, filePath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPresignedUrlForFileDeletion2(instanceId, filename, filePath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} instanceId 
         * @param {string} fileName 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPresignedUrlForFileDownload2(instanceId: string, fileName: string, filePath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPresignedUrlForFileDownload2(instanceId, fileName, filePath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} instanceId 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPresignedUrlForFileUpload2(instanceId: string, filename: string, filePath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPresignedUrlForFileUpload2(instanceId, filename, filePath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServiceInstanceFileRestControllerApi - factory interface
 * @export
 */
export const ServiceInstanceFileRestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceInstanceFileRestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} instanceId 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileNames2(instanceId: string, filePath: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getFileNames2(instanceId, filePath, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} instanceId 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileDeletion2(instanceId: string, filename: string, filePath: string, options?: any): AxiosPromise<string> {
            return localVarFp.getPresignedUrlForFileDeletion2(instanceId, filename, filePath, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} instanceId 
         * @param {string} fileName 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileDownload2(instanceId: string, fileName: string, filePath: string, options?: any): AxiosPromise<string> {
            return localVarFp.getPresignedUrlForFileDownload2(instanceId, fileName, filePath, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} instanceId 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileUpload2(instanceId: string, filename: string, filePath: string, options?: any): AxiosPromise<string> {
            return localVarFp.getPresignedUrlForFileUpload2(instanceId, filename, filePath, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getFileNames2 operation in ServiceInstanceFileRestControllerApi.
 * @export
 * @interface ServiceInstanceFileRestControllerApiGetFileNames2Request
 */
export interface ServiceInstanceFileRestControllerApiGetFileNames2Request {
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceFileRestControllerApiGetFileNames2
     */
    readonly instanceId: string

    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceFileRestControllerApiGetFileNames2
     */
    readonly filePath: string
}

/**
 * Request parameters for getPresignedUrlForFileDeletion2 operation in ServiceInstanceFileRestControllerApi.
 * @export
 * @interface ServiceInstanceFileRestControllerApiGetPresignedUrlForFileDeletion2Request
 */
export interface ServiceInstanceFileRestControllerApiGetPresignedUrlForFileDeletion2Request {
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceFileRestControllerApiGetPresignedUrlForFileDeletion2
     */
    readonly instanceId: string

    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceFileRestControllerApiGetPresignedUrlForFileDeletion2
     */
    readonly filename: string

    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceFileRestControllerApiGetPresignedUrlForFileDeletion2
     */
    readonly filePath: string
}

/**
 * Request parameters for getPresignedUrlForFileDownload2 operation in ServiceInstanceFileRestControllerApi.
 * @export
 * @interface ServiceInstanceFileRestControllerApiGetPresignedUrlForFileDownload2Request
 */
export interface ServiceInstanceFileRestControllerApiGetPresignedUrlForFileDownload2Request {
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceFileRestControllerApiGetPresignedUrlForFileDownload2
     */
    readonly instanceId: string

    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceFileRestControllerApiGetPresignedUrlForFileDownload2
     */
    readonly fileName: string

    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceFileRestControllerApiGetPresignedUrlForFileDownload2
     */
    readonly filePath: string
}

/**
 * Request parameters for getPresignedUrlForFileUpload2 operation in ServiceInstanceFileRestControllerApi.
 * @export
 * @interface ServiceInstanceFileRestControllerApiGetPresignedUrlForFileUpload2Request
 */
export interface ServiceInstanceFileRestControllerApiGetPresignedUrlForFileUpload2Request {
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceFileRestControllerApiGetPresignedUrlForFileUpload2
     */
    readonly instanceId: string

    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceFileRestControllerApiGetPresignedUrlForFileUpload2
     */
    readonly filename: string

    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceFileRestControllerApiGetPresignedUrlForFileUpload2
     */
    readonly filePath: string
}

/**
 * ServiceInstanceFileRestControllerApi - object-oriented interface
 * @export
 * @class ServiceInstanceFileRestControllerApi
 * @extends {BaseAPI}
 */
export class ServiceInstanceFileRestControllerApi extends BaseAPI {
    /**
     * 
     * @param {ServiceInstanceFileRestControllerApiGetFileNames2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceInstanceFileRestControllerApi
     */
    public getFileNames2(requestParameters: ServiceInstanceFileRestControllerApiGetFileNames2Request, options?: AxiosRequestConfig) {
        return ServiceInstanceFileRestControllerApiFp(this.configuration).getFileNames2(requestParameters.instanceId, requestParameters.filePath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ServiceInstanceFileRestControllerApiGetPresignedUrlForFileDeletion2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceInstanceFileRestControllerApi
     */
    public getPresignedUrlForFileDeletion2(requestParameters: ServiceInstanceFileRestControllerApiGetPresignedUrlForFileDeletion2Request, options?: AxiosRequestConfig) {
        return ServiceInstanceFileRestControllerApiFp(this.configuration).getPresignedUrlForFileDeletion2(requestParameters.instanceId, requestParameters.filename, requestParameters.filePath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ServiceInstanceFileRestControllerApiGetPresignedUrlForFileDownload2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceInstanceFileRestControllerApi
     */
    public getPresignedUrlForFileDownload2(requestParameters: ServiceInstanceFileRestControllerApiGetPresignedUrlForFileDownload2Request, options?: AxiosRequestConfig) {
        return ServiceInstanceFileRestControllerApiFp(this.configuration).getPresignedUrlForFileDownload2(requestParameters.instanceId, requestParameters.fileName, requestParameters.filePath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ServiceInstanceFileRestControllerApiGetPresignedUrlForFileUpload2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceInstanceFileRestControllerApi
     */
    public getPresignedUrlForFileUpload2(requestParameters: ServiceInstanceFileRestControllerApiGetPresignedUrlForFileUpload2Request, options?: AxiosRequestConfig) {
        return ServiceInstanceFileRestControllerApiFp(this.configuration).getPresignedUrlForFileUpload2(requestParameters.instanceId, requestParameters.filename, requestParameters.filePath, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServiceStartFileRestControllerApi - axios parameter creator
 * @export
 */
export const ServiceStartFileRestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} definitionKey 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileNames1: async (definitionKey: string, filePath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'definitionKey' is not null or undefined
            assertParamExists('getFileNames1', 'definitionKey', definitionKey)
            // verify required parameter 'filePath' is not null or undefined
            assertParamExists('getFileNames1', 'filePath', filePath)
            const localVarPath = `/rest/service/start/file/{definitionKey}`
                .replace(`{${"definitionKey"}}`, encodeURIComponent(String(definitionKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)

            if (filePath !== undefined) {
                localVarQueryParameter['filePath'] = filePath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} definitionKey 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileDeletion1: async (definitionKey: string, filename: string, filePath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'definitionKey' is not null or undefined
            assertParamExists('getPresignedUrlForFileDeletion1', 'definitionKey', definitionKey)
            // verify required parameter 'filename' is not null or undefined
            assertParamExists('getPresignedUrlForFileDeletion1', 'filename', filename)
            // verify required parameter 'filePath' is not null or undefined
            assertParamExists('getPresignedUrlForFileDeletion1', 'filePath', filePath)
            const localVarPath = `/rest/service/start/file/{definitionKey}/{filename}`
                .replace(`{${"definitionKey"}}`, encodeURIComponent(String(definitionKey)))
                .replace(`{${"filename"}}`, encodeURIComponent(String(filename)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)

            if (filePath !== undefined) {
                localVarQueryParameter['filePath'] = filePath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} definitionKey 
         * @param {string} fileName 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileDownload1: async (definitionKey: string, fileName: string, filePath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'definitionKey' is not null or undefined
            assertParamExists('getPresignedUrlForFileDownload1', 'definitionKey', definitionKey)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('getPresignedUrlForFileDownload1', 'fileName', fileName)
            // verify required parameter 'filePath' is not null or undefined
            assertParamExists('getPresignedUrlForFileDownload1', 'filePath', filePath)
            const localVarPath = `/rest/service/start/file/{definitionKey}/{fileName}`
                .replace(`{${"definitionKey"}}`, encodeURIComponent(String(definitionKey)))
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)

            if (filePath !== undefined) {
                localVarQueryParameter['filePath'] = filePath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} definitionKey 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileUpload1: async (definitionKey: string, filename: string, filePath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'definitionKey' is not null or undefined
            assertParamExists('getPresignedUrlForFileUpload1', 'definitionKey', definitionKey)
            // verify required parameter 'filename' is not null or undefined
            assertParamExists('getPresignedUrlForFileUpload1', 'filename', filename)
            // verify required parameter 'filePath' is not null or undefined
            assertParamExists('getPresignedUrlForFileUpload1', 'filePath', filePath)
            const localVarPath = `/rest/service/start/file/{definitionKey}/{filename}`
                .replace(`{${"definitionKey"}}`, encodeURIComponent(String(definitionKey)))
                .replace(`{${"filename"}}`, encodeURIComponent(String(filename)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)

            if (filePath !== undefined) {
                localVarQueryParameter['filePath'] = filePath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceStartFileRestControllerApi - functional programming interface
 * @export
 */
export const ServiceStartFileRestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceStartFileRestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} definitionKey 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileNames1(definitionKey: string, filePath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileNames1(definitionKey, filePath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} definitionKey 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPresignedUrlForFileDeletion1(definitionKey: string, filename: string, filePath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPresignedUrlForFileDeletion1(definitionKey, filename, filePath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} definitionKey 
         * @param {string} fileName 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPresignedUrlForFileDownload1(definitionKey: string, fileName: string, filePath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPresignedUrlForFileDownload1(definitionKey, fileName, filePath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} definitionKey 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPresignedUrlForFileUpload1(definitionKey: string, filename: string, filePath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPresignedUrlForFileUpload1(definitionKey, filename, filePath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServiceStartFileRestControllerApi - factory interface
 * @export
 */
export const ServiceStartFileRestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceStartFileRestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} definitionKey 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileNames1(definitionKey: string, filePath: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getFileNames1(definitionKey, filePath, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} definitionKey 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileDeletion1(definitionKey: string, filename: string, filePath: string, options?: any): AxiosPromise<string> {
            return localVarFp.getPresignedUrlForFileDeletion1(definitionKey, filename, filePath, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} definitionKey 
         * @param {string} fileName 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileDownload1(definitionKey: string, fileName: string, filePath: string, options?: any): AxiosPromise<string> {
            return localVarFp.getPresignedUrlForFileDownload1(definitionKey, fileName, filePath, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} definitionKey 
         * @param {string} filename 
         * @param {string} filePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileUpload1(definitionKey: string, filename: string, filePath: string, options?: any): AxiosPromise<string> {
            return localVarFp.getPresignedUrlForFileUpload1(definitionKey, filename, filePath, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getFileNames1 operation in ServiceStartFileRestControllerApi.
 * @export
 * @interface ServiceStartFileRestControllerApiGetFileNames1Request
 */
export interface ServiceStartFileRestControllerApiGetFileNames1Request {
    /**
     * 
     * @type {string}
     * @memberof ServiceStartFileRestControllerApiGetFileNames1
     */
    readonly definitionKey: string

    /**
     * 
     * @type {string}
     * @memberof ServiceStartFileRestControllerApiGetFileNames1
     */
    readonly filePath: string
}

/**
 * Request parameters for getPresignedUrlForFileDeletion1 operation in ServiceStartFileRestControllerApi.
 * @export
 * @interface ServiceStartFileRestControllerApiGetPresignedUrlForFileDeletion1Request
 */
export interface ServiceStartFileRestControllerApiGetPresignedUrlForFileDeletion1Request {
    /**
     * 
     * @type {string}
     * @memberof ServiceStartFileRestControllerApiGetPresignedUrlForFileDeletion1
     */
    readonly definitionKey: string

    /**
     * 
     * @type {string}
     * @memberof ServiceStartFileRestControllerApiGetPresignedUrlForFileDeletion1
     */
    readonly filename: string

    /**
     * 
     * @type {string}
     * @memberof ServiceStartFileRestControllerApiGetPresignedUrlForFileDeletion1
     */
    readonly filePath: string
}

/**
 * Request parameters for getPresignedUrlForFileDownload1 operation in ServiceStartFileRestControllerApi.
 * @export
 * @interface ServiceStartFileRestControllerApiGetPresignedUrlForFileDownload1Request
 */
export interface ServiceStartFileRestControllerApiGetPresignedUrlForFileDownload1Request {
    /**
     * 
     * @type {string}
     * @memberof ServiceStartFileRestControllerApiGetPresignedUrlForFileDownload1
     */
    readonly definitionKey: string

    /**
     * 
     * @type {string}
     * @memberof ServiceStartFileRestControllerApiGetPresignedUrlForFileDownload1
     */
    readonly fileName: string

    /**
     * 
     * @type {string}
     * @memberof ServiceStartFileRestControllerApiGetPresignedUrlForFileDownload1
     */
    readonly filePath: string
}

/**
 * Request parameters for getPresignedUrlForFileUpload1 operation in ServiceStartFileRestControllerApi.
 * @export
 * @interface ServiceStartFileRestControllerApiGetPresignedUrlForFileUpload1Request
 */
export interface ServiceStartFileRestControllerApiGetPresignedUrlForFileUpload1Request {
    /**
     * 
     * @type {string}
     * @memberof ServiceStartFileRestControllerApiGetPresignedUrlForFileUpload1
     */
    readonly definitionKey: string

    /**
     * 
     * @type {string}
     * @memberof ServiceStartFileRestControllerApiGetPresignedUrlForFileUpload1
     */
    readonly filename: string

    /**
     * 
     * @type {string}
     * @memberof ServiceStartFileRestControllerApiGetPresignedUrlForFileUpload1
     */
    readonly filePath: string
}

/**
 * ServiceStartFileRestControllerApi - object-oriented interface
 * @export
 * @class ServiceStartFileRestControllerApi
 * @extends {BaseAPI}
 */
export class ServiceStartFileRestControllerApi extends BaseAPI {
    /**
     * 
     * @param {ServiceStartFileRestControllerApiGetFileNames1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceStartFileRestControllerApi
     */
    public getFileNames1(requestParameters: ServiceStartFileRestControllerApiGetFileNames1Request, options?: AxiosRequestConfig) {
        return ServiceStartFileRestControllerApiFp(this.configuration).getFileNames1(requestParameters.definitionKey, requestParameters.filePath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ServiceStartFileRestControllerApiGetPresignedUrlForFileDeletion1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceStartFileRestControllerApi
     */
    public getPresignedUrlForFileDeletion1(requestParameters: ServiceStartFileRestControllerApiGetPresignedUrlForFileDeletion1Request, options?: AxiosRequestConfig) {
        return ServiceStartFileRestControllerApiFp(this.configuration).getPresignedUrlForFileDeletion1(requestParameters.definitionKey, requestParameters.filename, requestParameters.filePath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ServiceStartFileRestControllerApiGetPresignedUrlForFileDownload1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceStartFileRestControllerApi
     */
    public getPresignedUrlForFileDownload1(requestParameters: ServiceStartFileRestControllerApiGetPresignedUrlForFileDownload1Request, options?: AxiosRequestConfig) {
        return ServiceStartFileRestControllerApiFp(this.configuration).getPresignedUrlForFileDownload1(requestParameters.definitionKey, requestParameters.fileName, requestParameters.filePath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ServiceStartFileRestControllerApiGetPresignedUrlForFileUpload1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceStartFileRestControllerApi
     */
    public getPresignedUrlForFileUpload1(requestParameters: ServiceStartFileRestControllerApiGetPresignedUrlForFileUpload1Request, options?: AxiosRequestConfig) {
        return ServiceStartFileRestControllerApiFp(this.configuration).getPresignedUrlForFileUpload1(requestParameters.definitionKey, requestParameters.filename, requestParameters.filePath, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserRestControllerApi - axios parameter creator
 * @export
 */
export const UserRestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUser', 'id', id)
            const localVarPath = `/rest/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByUsername: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getUserByUsername', 'username', username)
            const localVarPath = `/rest/user/uid/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SearchUserTO} searchUserTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (searchUserTO: SearchUserTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchUserTO' is not null or undefined
            assertParamExists('getUsers', 'searchUserTO', searchUserTO)
            const localVarPath = `/rest/user/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchUserTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userinfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/user/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserRestControllerApi - functional programming interface
 * @export
 */
export const UserRestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserRestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserByUsername(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserByUsername(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SearchUserTO} searchUserTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(searchUserTO: SearchUserTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(searchUserTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userinfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userinfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserRestControllerApi - factory interface
 * @export
 */
export const UserRestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserRestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id: string, options?: any): AxiosPromise<UserTO> {
            return localVarFp.getUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByUsername(username: string, options?: any): AxiosPromise<UserTO> {
            return localVarFp.getUserByUsername(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SearchUserTO} searchUserTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(searchUserTO: SearchUserTO, options?: any): AxiosPromise<Array<UserTO>> {
            return localVarFp.getUsers(searchUserTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userinfo(options?: any): AxiosPromise<UserTO> {
            return localVarFp.userinfo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getUser operation in UserRestControllerApi.
 * @export
 * @interface UserRestControllerApiGetUserRequest
 */
export interface UserRestControllerApiGetUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UserRestControllerApiGetUser
     */
    readonly id: string
}

/**
 * Request parameters for getUserByUsername operation in UserRestControllerApi.
 * @export
 * @interface UserRestControllerApiGetUserByUsernameRequest
 */
export interface UserRestControllerApiGetUserByUsernameRequest {
    /**
     * 
     * @type {string}
     * @memberof UserRestControllerApiGetUserByUsername
     */
    readonly username: string
}

/**
 * Request parameters for getUsers operation in UserRestControllerApi.
 * @export
 * @interface UserRestControllerApiGetUsersRequest
 */
export interface UserRestControllerApiGetUsersRequest {
    /**
     * 
     * @type {SearchUserTO}
     * @memberof UserRestControllerApiGetUsers
     */
    readonly searchUserTO: SearchUserTO
}

/**
 * UserRestControllerApi - object-oriented interface
 * @export
 * @class UserRestControllerApi
 * @extends {BaseAPI}
 */
export class UserRestControllerApi extends BaseAPI {
    /**
     * 
     * @param {UserRestControllerApiGetUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRestControllerApi
     */
    public getUser(requestParameters: UserRestControllerApiGetUserRequest, options?: AxiosRequestConfig) {
        return UserRestControllerApiFp(this.configuration).getUser(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserRestControllerApiGetUserByUsernameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRestControllerApi
     */
    public getUserByUsername(requestParameters: UserRestControllerApiGetUserByUsernameRequest, options?: AxiosRequestConfig) {
        return UserRestControllerApiFp(this.configuration).getUserByUsername(requestParameters.username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserRestControllerApiGetUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRestControllerApi
     */
    public getUsers(requestParameters: UserRestControllerApiGetUsersRequest, options?: AxiosRequestConfig) {
        return UserRestControllerApiFp(this.configuration).getUsers(requestParameters.searchUserTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRestControllerApi
     */
    public userinfo(options?: AxiosRequestConfig) {
        return UserRestControllerApiFp(this.configuration).userinfo(options).then((request) => request(this.axios, this.basePath));
    }
}


